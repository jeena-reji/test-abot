name: Cleanup Failed Workflow Runs

on:
  workflow_dispatch:  # Manual trigger - run it from the GitHub UI when you want

permissions:
  actions: write  # Required to delete workflow runs via API
  contents: read  # Optional, for any repo access

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (optional, for context)
        uses: actions/checkout@v4

      - name: List and delete failed runs
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}  # Default GitHub token (actions:write scope)
        run: |
          echo "Fetching list of failed workflow runs..."
          
          # List all failed runs and extract their database IDs (run IDs)
          RUN_IDS=$(gh run list \
            --repo ${{ github.repository }} \
            --status failure \
            --json databaseId \
            --limit 1000 \
            -q '.[].databaseId' 2>/dev/null || echo "")
          
          if [ -z "$RUN_IDS" ]; then
            echo "No failed runs found to delete."
            exit 0
          fi
          
          TOTAL_COUNT=$(echo "$RUN_IDS" | wc -w)
          echo "Found $TOTAL_COUNT failed run(s) to delete."
          echo "Sample Run IDs (first 5): $(echo "$RUN_IDS" | cut -d' ' -f1-5)"  # Truncated for readability
          
          # Initialize counters
          DELETED_COUNT=0
          FAILED_COUNT=0
          
          # Delete each run using GitHub API (non-interactive, continues on errors)
          for RUN_ID in $RUN_IDS; do
            echo "Attempting to delete run ID: $RUN_ID"
            
            # Temp file for response body
            RESPONSE_BODY=$(mktemp)
            
            # Curl WITHOUT -f: Always succeeds (exit 0), we check HTTP_CODE
            HTTP_CODE=$(curl -s -w "%{http_code}" -o "$RESPONSE_BODY" -X DELETE \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID")
            
            CURL_EXIT=$?
            
            # Capture body BEFORE cleanup (empty on 204 success)
            BODY=$(cat "$RESPONSE_BODY" 2>/dev/null || echo "")
            rm -f "$RESPONSE_BODY"
            
            if [ $CURL_EXIT -ne 0 ]; then
              echo "  -> Curl failed for run $RUN_ID (exit $CURL_EXIT) - skipping."
              ((FAILED_COUNT++))
              sleep 1
              continue
            fi
            
            if [ "$HTTP_CODE" = "204" ]; then
              echo "  -> Successfully deleted run $RUN_ID"
              ((DELETED_COUNT++))
            else
              # Parse body for error details (safe: jq on empty is fine)
              PARSED_BODY=$(echo "$BODY" | jq -r '.message // empty' 2>/dev/null || echo "$BODY")
              if [ -z "$PARSED_BODY" ]; then
                PARSED_BODY="Unknown error (empty response)"
              fi
              echo "  -> Failed to delete run $RUN_ID (HTTP $HTTP_CODE): $PARSED_BODY"
              ((FAILED_COUNT++))
            fi
            
            # Delay to avoid rate limits
            sleep 1
          done
          
          echo "Cleanup complete!"
          echo "Summary: Successfully deleted $DELETED_COUNT out of $TOTAL_COUNT runs."
          echo "Skipped failures: $FAILED_COUNT (normal for already-deleted runs or permissions)."
          
          # Always succeed: Partial cleanup is progress
          exit 0
