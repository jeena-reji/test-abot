name: Cleanup Failed Workflow Runs

on:
  workflow_dispatch:  # Manual trigger - run it from the GitHub UI when you want

permissions:
  actions: write  # Required to delete workflow runs via API
  contents: read  # Optional, for any repo access

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (optional, for context)
        uses: actions/checkout@v4

      - name: List and delete failed runs
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}  # Uses default token with repo scopes
        run: |
          echo "Fetching list of failed workflow runs..."
          
          # List all failed runs and extract their database IDs (run IDs)
          # --limit 1000 is a safe high limit; gh handles pagination automatically for list
          RUN_IDS=$(gh run list \
            --repo ${{ github.repository }} \
            --status failure \
            --json databaseId \
            --limit 1000 \
            -q '.[].databaseId' 2>/dev/null || echo "")
          
          if [ -z "$RUN_IDS" ]; then
            echo "No failed runs found to delete."
            exit 0
          fi
          
          echo "Found $(echo $RUN_IDS | wc -w) failed run(s) to delete."
          echo "Run IDs: $RUN_IDS"
          
          # Delete each run using GitHub API (non-interactive)
          DELETED_COUNT=0
          TOTAL_COUNT=$(echo $RUN_IDS | wc -w)
          for RUN_ID in $RUN_IDS; do
            echo "Deleting run ID: $RUN_ID"
            
            # Use curl with output to temp file for body, and capture HTTP code
            RESPONSE_BODY=$(mktemp)
            HTTP_CODE=$(curl -s -w "%{http_code}" -o "$RESPONSE_BODY" -X DELETE \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID" \
              -f)  # -f makes curl exit non-zero on HTTP >=400
            
            CURL_EXIT=$?
            
            if [ $CURL_EXIT -eq 0 ] && [ "$HTTP_CODE" = "204" ]; then
              echo "Successfully deleted run $RUN_ID"
              ((DELETED_COUNT++))
            else
              # Read body only if file exists and has content
              BODY=$(cat "$RESPONSE_BODY" 2>/dev/null || echo "No response body")
              rm -f "$RESPONSE_BODY"
              if [ $CURL_EXIT -eq 0 ]; then
                echo "Failed to delete run $RUN_ID (HTTP $HTTP_CODE): $BODY"
              else
                echo "Curl failed for run $RUN_ID (exit $CURL_EXIT). HTTP code: $HTTP_CODE. Body: $BODY"
              fi
            fi
            rm -f "$RESPONSE_BODY"  # Clean up temp file
            
            # Small delay to avoid rate limits
            sleep 1
          done
          
          echo "Cleanup complete! Successfully deleted $DELETED_COUNT out of $TOTAL_COUNT runs."
          # Always exit 0 to mark step as successful (partial deletions are okay)
          exit 0
